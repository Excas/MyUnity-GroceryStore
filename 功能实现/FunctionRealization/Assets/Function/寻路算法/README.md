# 寻路算法

# 工程
* AstarForUnity： https://github.com/Mr-susu/AstarForUnity/tree/master
* Unity-PathFindingAlgorithms：https://github.com/dbrizov/Unity-PathFindingAlgorithms


# Dijkstra算法：
该算法基于贪心策略，在加权图中找到起点到所有其他点的最短路径。Dijkstra算法的核心思想是通过维护一个待扩展的点集合来找到最短路径。每次从待扩展的点集中选取距离起点最短的点，然后将它的相邻节点加入待扩展点集中，更新距离值，直到终点被加入点集或者点集为空。

## 实现
1. 初始化距离数组dist，将起点距离设为0，其他节点距离设为正无穷。
2. 将起点加入待扩展节点集合中。
3. 从待扩展节点集合中选取距离起点最短的节点v，将其从集合中移除。
4. 遍历节点v的所有邻居节点w，计算从起点到w的距离，如果这个距离小于当前记录的距离，则更新w的距离值，并将w加入待扩展节点集合中。
5. 重复步骤c和d，直到终点被加入待扩展节点集合中或者节点集合为空。

# A算法：
该算法是一种启发式搜索算法，它在Dijkstra算法的基础上引入了启发式函数（通常使用估价函数）来优化搜索效率。它通过在扩展节点时优先选择估价函数值最小的节点，从而更快地找到最短路径。A算法的效率比Dijkstra算法更高，因为它在扩展节点时有了更好的优先级顺序。

## 实现
1. 初始化开放列表和关闭列表，将起点加入开放列表中。
2. 从开放列表中选取f值最小的节点v，将其从开放列表中移除并加入关闭列表中。
3. 遍历节点v的所有邻居节点w，计算从起点到w的距离g和从w到终点的估价函数值h，将g+h作为w的f值，如果w不在开放列表或者w的f值比之前记录的f值更小，则更新w的父节点为v，更新或添加w到开放列表中。
4. 重复步骤b和c，直到终点被加入关闭列表中或者开放列表为空。

# BFS算法：
该算法使用广度优先搜索策略，逐层遍历图中所有节点，从起点开始搜索直到找到目标节点。BFS算法可以保证找到的路径是最短的，但当图比较大或搜索深度较大时，它的时间复杂度会变得非常高。

## 实现
1. 初始化队列，将起点加入队列中。
2. 从队列中取出一个节点v，遍历节点v的所有邻居节点w，如果w未被访问过，则将w标记为已访问并加入队列中。
3. 重复步骤b，直到找到终点或者队列为空。

# DFS算法：
该算法使用深度优先搜索策略，它从起点开始，一直往某个方向走到无法再走为止，然后回溯到前一个节点，继续尝试其他方向。DFS算法的路径不一定是最短的，但它的搜索过程比BFS算法要快，因为它不需要存储所有已经访问过的节点。